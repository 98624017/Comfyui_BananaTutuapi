---
name: unify-error-handling
epic: image-generation-enhancement
status: todo
priority: medium
created: 2025-09-17T16:16:26Z
updated: 2025-09-17T17:53:16Z
estimated_hours: 10
phase: 2
depends_on: [5]
tags: [error-handling, user-experience, logging, debugging]
github: https://github.com/98624017/Comfyui_BananaTutuapi/issues/8
---

# Task: 统一错误处理机制

## Overview
建立统一的错误处理和用户反馈机制，改善用户体验，提供更清晰的错误信息和调试支持。

## Technical Details

### Error Handling Strategy

#### 1. 错误分类和定义
```python
class TutuAPIError(Exception):
    """Tutu API 基础异常类"""
    def __init__(self, message, error_code=None, provider=None):
        self.message = message
        self.error_code = error_code
        self.provider = provider
        super().__init__(self.message)

class ConfigurationError(TutuAPIError):
    """配置相关错误"""
    pass

class APIConnectionError(TutuAPIError):
    """API 连接错误"""
    pass

class APIResponseError(TutuAPIError):
    """API 响应错误"""
    pass

class ImageGenerationError(TutuAPIError):
    """图像生成相关错误"""
    pass
```

#### 2. 统一错误处理函数
```python
def handle_api_error(error, provider, context=""):
    """统一处理 API 错误"""
    import traceback

    # 记录详细错误信息供调试
    debug_info = {
        "provider": provider,
        "context": context,
        "error_type": type(error).__name__,
        "error_message": str(error),
        "traceback": traceback.format_exc()
    }

    print(f"[Tutu Debug] {debug_info}")

    # 根据错误类型提供用户友好的消息
    if isinstance(error, requests.exceptions.ConnectionError):
        user_message = f"无法连接到 {provider} 服务器，请检查网络连接"
        return create_error_output(user_message, "connection_error")

    elif isinstance(error, requests.exceptions.Timeout):
        user_message = f"{provider} 服务响应超时，请稍后重试"
        return create_error_output(user_message, "timeout_error")

    elif isinstance(error, json.JSONDecodeError):
        user_message = f"{provider} 返回了无效的响应格式"
        return create_error_output(user_message, "response_format_error")

    else:
        user_message = f"{provider} 服务出现错误: {str(error)}"
        return create_error_output(user_message, "general_error")

def create_error_output(message, error_type):
    """创建错误输出，返回默认图像和错误信息"""
    # 创建错误提示图像
    error_image = create_error_image_with_text(message)
    error_tensor = pil2tensor(error_image)

    return (error_tensor, message, error_type)
```

#### 3. 改进的响应处理
```python
def process_api_response(response, provider, num_images):
    """统一处理各提供商的 API 响应"""
    try:
        if provider == "APICore.ai":
            return process_apicore_response(response, num_images)
        else:
            return process_openai_style_response(response, num_images)

    except Exception as e:
        raise APIResponseError(
            f"处理 {provider} 响应时出错: {str(e)}",
            provider=provider
        )

def validate_image_response(images, expected_count, provider):
    """验证返回的图像数量和质量"""
    if not images:
        raise ImageGenerationError(
            f"{provider} 未返回任何图像",
            provider=provider
        )

    if len(images) != expected_count:
        print(f"[Tutu Warning] {provider} 返回了 {len(images)} 张图像，期望 {expected_count} 张")

    # 验证图像有效性
    valid_images = []
    for i, image in enumerate(images):
        if image and hasattr(image, 'size'):
            valid_images.append(image)
        else:
            print(f"[Tutu Warning] 第 {i+1} 张图像无效，已跳过")

    if not valid_images:
        raise ImageGenerationError(
            f"{provider} 返回的图像都无效",
            provider=provider
        )

    return valid_images
```

#### 4. 用户反馈改进
```python
def create_error_image_with_text(error_message):
    """创建包含错误信息的图像"""
    from PIL import Image, ImageDraw, ImageFont
    import textwrap

    # 创建错误提示图像
    img = Image.new('RGB', (512, 512), color='#ffebee')
    draw = ImageDraw.Draw(img)

    try:
        # 尝试使用系统字体
        font = ImageFont.truetype("arial.ttf", 20)
    except:
        font = ImageFont.load_default()

    # 包装文本
    wrapped_text = textwrap.fill(error_message, width=40)
    draw.text((10, 200), wrapped_text, fill='#d32f2f', font=font)

    return img

def get_user_friendly_message(provider, error_type):
    """根据提供商和错误类型返回友好消息"""
    messages = {
        ("APICore.ai", "connection_error"): "APICore.ai 服务暂时不可用，请检查网络或稍后重试",
        ("APICore.ai", "auth_error"): "APICore.ai API 密钥无效，请检查配置",
        ("OpenRouter", "quota_exceeded"): "OpenRouter 配额已用完，请检查账户余额",
        ("ai.comfly.chat", "model_unavailable"): "选择的模型暂时不可用，请尝试其他模型"
    }

    return messages.get((provider, error_type), f"{provider} 服务出现问题，请稍后重试")
```

### Integration Points

#### 1. 在主生成函数中集成
```python
def generate(self, prompt, ...):
    try:
        # 现有的生成逻辑
        result = perform_image_generation(...)
        return result

    except TutuAPIError as e:
        return handle_api_error(e, api_provider, "image_generation")

    except Exception as e:
        # 处理未预期的错误
        wrapped_error = TutuAPIError(f"未知错误: {str(e)}")
        return handle_api_error(wrapped_error, api_provider, "unexpected")
```

#### 2. 改进日志记录
```python
import logging

# 配置日志记录
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] [%(name)s] [%(levelname)s] %(message)s'
)
logger = logging.getLogger('TutuAPI')

def log_api_call(provider, model, num_images, success=True):
    """记录 API 调用统计"""
    if success:
        logger.info(f"成功调用 {provider} - {model} - 生成 {num_images} 张图像")
    else:
        logger.warning(f"调用 {provider} - {model} 失败")
```

## Acceptance Criteria
- [ ] 所有 API 错误都有统一的处理机制
- [ ] 用户看到清晰、友好的错误信息
- [ ] 错误情况下返回有意义的错误图像
- [ ] 开发者可以通过日志进行调试
- [ ] 不同提供商的错误处理保持一致
- [ ] 网络、认证、响应等各类错误都有专门处理

## Risk Factors
- **低风险**: 错误处理改进不会影响正常功能
- **中风险**: 过度的错误处理可能隐藏真实问题
- **缓解**: 保留详细的调试日志，平衡用户体验和调试需求

## Dependencies
- 依赖 Task 11 (integrate-apicore-basic-support) 的基础架构
- 需要与其他任务协调，确保错误处理一致性

## Estimated Effort
- **错误类型定义**: 2小时
- **统一处理机制**: 4小时
- **用户反馈改进**: 2小时
- **日志和调试**: 2小时
- **总计**: 10小时 (1.25个工作日)